Gu.Roslyn.AnalyzerExtensions.AccessibilityExt
Gu.Roslyn.AnalyzerExtensions.AliasWalker
Gu.Roslyn.AnalyzerExtensions.AliasWalker.Aliases.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax>
Gu.Roslyn.AnalyzerExtensions.ArgumentListSyntaxExt
Gu.Roslyn.AnalyzerExtensions.ArgumentSyntaxExt
Gu.Roslyn.AnalyzerExtensions.AssemblySymbolComparer
Gu.Roslyn.AnalyzerExtensions.AssemblySymbolComparer.GetHashCode(Microsoft.CodeAnalysis.IAssemblySymbol obj) -> int
Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker
Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker.Assignments.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax>
Gu.Roslyn.AnalyzerExtensions.Attribute
Gu.Roslyn.AnalyzerExtensions.BaseMethodDeclarationSyntaxExt
Gu.Roslyn.AnalyzerExtensions.BasePropertyDeclarationSyntaxExt
Gu.Roslyn.AnalyzerExtensions.BlockSyntaxExt
Gu.Roslyn.AnalyzerExtensions.Cache
Gu.Roslyn.AnalyzerExtensions.Cache<TKey, TValue>
Gu.Roslyn.AnalyzerExtensions.Cache<TKey, TValue>.Transaction_
Gu.Roslyn.AnalyzerExtensions.Cache<TKey, TValue>.Transaction_.Dispose() -> void
Gu.Roslyn.AnalyzerExtensions.Cache<TKey, TValue>.Transaction_.Transaction_() -> void
Gu.Roslyn.AnalyzerExtensions.Constructor
Gu.Roslyn.AnalyzerExtensions.ConstructorInitializerSyntaxExt
Gu.Roslyn.AnalyzerExtensions.DiagnosticDescriptorExt
Gu.Roslyn.AnalyzerExtensions.DocumentationCommentTriviaSyntaxExtensions
Gu.Roslyn.AnalyzerExtensions.EnumerableExt
Gu.Roslyn.AnalyzerExtensions.EventSymbolComparer
Gu.Roslyn.AnalyzerExtensions.EventSymbolComparer.GetHashCode(Microsoft.CodeAnalysis.IEventSymbol obj) -> int
Gu.Roslyn.AnalyzerExtensions.ExecutedBefore
Gu.Roslyn.AnalyzerExtensions.ExecutedBefore.Maybe = 3 -> Gu.Roslyn.AnalyzerExtensions.ExecutedBefore
Gu.Roslyn.AnalyzerExtensions.ExecutedBefore.No = 2 -> Gu.Roslyn.AnalyzerExtensions.ExecutedBefore
Gu.Roslyn.AnalyzerExtensions.ExecutedBefore.Unknown = 0 -> Gu.Roslyn.AnalyzerExtensions.ExecutedBefore
Gu.Roslyn.AnalyzerExtensions.ExecutedBefore.Yes = 1 -> Gu.Roslyn.AnalyzerExtensions.ExecutedBefore
Gu.Roslyn.AnalyzerExtensions.ExecutedBeforeExt
Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>
Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.CancellationToken.get -> System.Threading.CancellationToken
Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.CancellationToken.set -> void
Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.ContainingType.get -> Microsoft.CodeAnalysis.ITypeSymbol
Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.ContainingType.set -> void
Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.ExecutionWalker() -> void
Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.Scope.get -> Gu.Roslyn.AnalyzerExtensions.Scope
Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.Scope.set -> void
Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.SemanticModel.get -> Microsoft.CodeAnalysis.SemanticModel
Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.SemanticModel.set -> void
Gu.Roslyn.AnalyzerExtensions.ExpressionSyntaxExt
Gu.Roslyn.AnalyzerExtensions.FieldDeclarationSyntaxExt
Gu.Roslyn.AnalyzerExtensions.FieldOrProperty
Gu.Roslyn.AnalyzerExtensions.FieldOrProperty.ContainingType.get -> Microsoft.CodeAnalysis.INamedTypeSymbol
Gu.Roslyn.AnalyzerExtensions.FieldOrProperty.FieldOrProperty() -> void
Gu.Roslyn.AnalyzerExtensions.FieldOrProperty.FieldOrProperty(Microsoft.CodeAnalysis.IFieldSymbol field) -> void
Gu.Roslyn.AnalyzerExtensions.FieldOrProperty.FieldOrProperty(Microsoft.CodeAnalysis.IPropertySymbol property) -> void
Gu.Roslyn.AnalyzerExtensions.FieldOrProperty.Initializer(System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax
Gu.Roslyn.AnalyzerExtensions.FieldOrProperty.IsStatic.get -> bool
Gu.Roslyn.AnalyzerExtensions.FieldOrProperty.Name.get -> string
Gu.Roslyn.AnalyzerExtensions.FieldOrProperty.Symbol.get -> Microsoft.CodeAnalysis.ISymbol
Gu.Roslyn.AnalyzerExtensions.FieldOrProperty.Type.get -> Microsoft.CodeAnalysis.ITypeSymbol
Gu.Roslyn.AnalyzerExtensions.FieldSymbolComparer
Gu.Roslyn.AnalyzerExtensions.FieldSymbolComparer.GetHashCode(Microsoft.CodeAnalysis.IFieldSymbol obj) -> int
Gu.Roslyn.AnalyzerExtensions.ILocalSymbolExt
Gu.Roslyn.AnalyzerExtensions.IMethodSymbolExt
Gu.Roslyn.AnalyzerExtensions.INamedTypeSymbolExtensions
Gu.Roslyn.AnalyzerExtensions.IParameterSymbolExt
Gu.Roslyn.AnalyzerExtensions.IPropertySymbolExt
Gu.Roslyn.AnalyzerExtensions.ISymbolExt
Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt
Gu.Roslyn.AnalyzerExtensions.IdentifierNameExecutionWalker
Gu.Roslyn.AnalyzerExtensions.IdentifierNameExecutionWalker.IdentifierNames.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax>
Gu.Roslyn.AnalyzerExtensions.IdentifierNameExecutionWalker.TryFind(string name, out Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifierName) -> bool
Gu.Roslyn.AnalyzerExtensions.IdentifierNameSyntaxExtensions
Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker
Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.IdentifierNames.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax>
Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.RemoveAll(System.Predicate<Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> match) -> void
Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.TryFind(string name, out Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifierName) -> bool
Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.TryFindFirst(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifierName) -> bool
Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.TryFindLast(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifierName) -> bool
Gu.Roslyn.AnalyzerExtensions.IdentifierTokenWalker
Gu.Roslyn.AnalyzerExtensions.IdentifierTokenWalker.IdentifierTokens.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.SyntaxToken>
Gu.Roslyn.AnalyzerExtensions.IdentifierTokenWalker.TryFind(string name, out Microsoft.CodeAnalysis.SyntaxToken identifierToken) -> bool
Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt
Gu.Roslyn.AnalyzerExtensions.LocalOrParameter
Gu.Roslyn.AnalyzerExtensions.LocalOrParameter.ContainingSymbol.get -> Microsoft.CodeAnalysis.ISymbol
Gu.Roslyn.AnalyzerExtensions.LocalOrParameter.LocalOrParameter() -> void
Gu.Roslyn.AnalyzerExtensions.LocalOrParameter.LocalOrParameter(Microsoft.CodeAnalysis.ILocalSymbol local) -> void
Gu.Roslyn.AnalyzerExtensions.LocalOrParameter.LocalOrParameter(Microsoft.CodeAnalysis.IParameterSymbol parameter) -> void
Gu.Roslyn.AnalyzerExtensions.LocalOrParameter.Name.get -> string
Gu.Roslyn.AnalyzerExtensions.LocalOrParameter.Symbol.get -> Microsoft.CodeAnalysis.ISymbol
Gu.Roslyn.AnalyzerExtensions.LocalOrParameter.TryGetScope(System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.SyntaxNode scope) -> bool
Gu.Roslyn.AnalyzerExtensions.LocalOrParameter.Type.get -> Microsoft.CodeAnalysis.ITypeSymbol
Gu.Roslyn.AnalyzerExtensions.LocalSymbolComparer
Gu.Roslyn.AnalyzerExtensions.LocalSymbolComparer.GetHashCode(Microsoft.CodeAnalysis.ILocalSymbol obj) -> int
Gu.Roslyn.AnalyzerExtensions.MemberAccessExpressionSyntaxExtensions
Gu.Roslyn.AnalyzerExtensions.MemberDeclarationSyntaxExtensions
Gu.Roslyn.AnalyzerExtensions.MemberPath
Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker
Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker.IdentifierNames.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax>
Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker.StartsWith(Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker other) -> bool
Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker.StartsWith(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax other) -> bool
Gu.Roslyn.AnalyzerExtensions.MethodSymbolComparer
Gu.Roslyn.AnalyzerExtensions.MethodSymbolComparer.GetHashCode(Microsoft.CodeAnalysis.IMethodSymbol obj) -> int
Gu.Roslyn.AnalyzerExtensions.MutationWalker
Gu.Roslyn.AnalyzerExtensions.MutationWalker.All() -> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode>
Gu.Roslyn.AnalyzerExtensions.MutationWalker.Assignments.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax>
Gu.Roslyn.AnalyzerExtensions.MutationWalker.IsEmpty.get -> bool
Gu.Roslyn.AnalyzerExtensions.MutationWalker.PostfixUnaries.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax>
Gu.Roslyn.AnalyzerExtensions.MutationWalker.PrefixUnaries.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax>
Gu.Roslyn.AnalyzerExtensions.MutationWalker.RefOrOutArguments.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax>
Gu.Roslyn.AnalyzerExtensions.MutationWalker.TrySingle(out Microsoft.CodeAnalysis.SyntaxNode mutation) -> bool
Gu.Roslyn.AnalyzerExtensions.NamedTypeSymbolComparer
Gu.Roslyn.AnalyzerExtensions.NamedTypeSymbolComparer.GetHashCode(Microsoft.CodeAnalysis.INamedTypeSymbol obj) -> int
Gu.Roslyn.AnalyzerExtensions.NamespaceParts
Gu.Roslyn.AnalyzerExtensions.NamespaceSymbolComparer
Gu.Roslyn.AnalyzerExtensions.NamespaceSymbolComparer.GetHashCode(Microsoft.CodeAnalysis.INamespaceSymbol obj) -> int
Gu.Roslyn.AnalyzerExtensions.NullCheck
Gu.Roslyn.AnalyzerExtensions.NullCheckWalker
Gu.Roslyn.AnalyzerExtensions.NullCheckWalker.TryGetFirst(Microsoft.CodeAnalysis.IParameterSymbol parameter, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax check) -> bool
Gu.Roslyn.AnalyzerExtensions.ObjectCreationExpressionSyntaxExt
Gu.Roslyn.AnalyzerExtensions.ParameterListSyntaxExt
Gu.Roslyn.AnalyzerExtensions.ParameterSymbolComparer
Gu.Roslyn.AnalyzerExtensions.ParameterSymbolComparer.GetHashCode(Microsoft.CodeAnalysis.IParameterSymbol obj) -> int
Gu.Roslyn.AnalyzerExtensions.PooledDictionary
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> item) -> void
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Add(TKey key, TValue value) -> void
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Clear() -> void
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> item) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.ContainsKey(TKey key) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue>[] array, int arrayIndex) -> void
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Count.get -> int
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Dispose() -> void
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.GetEnumerator() -> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.IsReadOnly.get -> bool
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Keys.get -> System.Collections.Generic.ICollection<TKey>
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue> item) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Remove(TKey key) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.TryGetValue(TKey key, out TValue value) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Values.get -> System.Collections.Generic.ICollection<TValue>
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.this[TKey key].get -> TValue
Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.this[TKey key].set -> void
Gu.Roslyn.AnalyzerExtensions.PooledList
Gu.Roslyn.AnalyzerExtensions.PooledList<T>
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.Add(T item) -> void
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.Clear() -> void
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.Contains(T item) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.CopyTo(T[] array, int arrayIndex) -> void
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.Count.get -> int
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.Dispose() -> void
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.IndexOf(T item) -> int
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.Insert(int index, T item) -> void
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.IsReadOnly.get -> bool
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.Remove(T item) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.RemoveAt(int index) -> void
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.this[int index].get -> T
Gu.Roslyn.AnalyzerExtensions.PooledList<T>.this[int index].set -> void
Gu.Roslyn.AnalyzerExtensions.PooledSet
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.Add(T item) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.Clear() -> void
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.Comparer.get -> System.Collections.Generic.IEqualityComparer<T>
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.Contains(T item) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.Count.get -> int
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.Dispose() -> void
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.ExceptWith(System.Collections.Generic.IEnumerable<T> other) -> void
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.IntersectWith(System.Collections.Generic.IEnumerable<T> other) -> void
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.Remove(T item) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.SetEquals(System.Collections.Generic.IEnumerable<T> items) -> bool
Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.UnionWith(System.Collections.Generic.IEnumerable<T> other) -> void
Gu.Roslyn.AnalyzerExtensions.PooledWalker<T>
Gu.Roslyn.AnalyzerExtensions.PooledWalker<T>.Dispose() -> void
Gu.Roslyn.AnalyzerExtensions.PooledWalker<T>.PooledWalker(Microsoft.CodeAnalysis.SyntaxWalkerDepth depth = Microsoft.CodeAnalysis.SyntaxWalkerDepth.Node) -> void
Gu.Roslyn.AnalyzerExtensions.PooledWalker<T>.ThrowIfDisposed() -> void
Gu.Roslyn.AnalyzerExtensions.PropertyDeclarationSyntaxExt
Gu.Roslyn.AnalyzerExtensions.PropertySymbolComparer
Gu.Roslyn.AnalyzerExtensions.PropertySymbolComparer.GetHashCode(Microsoft.CodeAnalysis.IPropertySymbol obj) -> int
Gu.Roslyn.AnalyzerExtensions.QualifiedArrayType
Gu.Roslyn.AnalyzerExtensions.QualifiedArrayType.ElementType.get -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
Gu.Roslyn.AnalyzerExtensions.QualifiedArrayType.QualifiedArrayType(Gu.Roslyn.AnalyzerExtensions.QualifiedType elementType) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedEvent
Gu.Roslyn.AnalyzerExtensions.QualifiedEvent.QualifiedEvent(Gu.Roslyn.AnalyzerExtensions.QualifiedType containingType, string name) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedField
Gu.Roslyn.AnalyzerExtensions.QualifiedField.QualifiedField(Gu.Roslyn.AnalyzerExtensions.QualifiedType containingType, string name) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedGenericType
Gu.Roslyn.AnalyzerExtensions.QualifiedGenericType.QualifiedGenericType(string fullName, System.Collections.Immutable.ImmutableArray<Gu.Roslyn.AnalyzerExtensions.QualifiedType> typeArguments) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedGenericType.TypeArguments.get -> System.Collections.Immutable.ImmutableArray<Gu.Roslyn.AnalyzerExtensions.QualifiedType>
Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T>
Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T>.ContainingType.get -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T>.Name.get -> string
Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T>.QualifiedMember(Gu.Roslyn.AnalyzerExtensions.QualifiedType containingType, string name) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedMethod
Gu.Roslyn.AnalyzerExtensions.QualifiedMethod.QualifiedMethod(Gu.Roslyn.AnalyzerExtensions.QualifiedType containingType, string name) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedOverload
Gu.Roslyn.AnalyzerExtensions.QualifiedOverload.Parameters.get -> System.Collections.Immutable.ImmutableArray<Gu.Roslyn.AnalyzerExtensions.QualifiedParameter>
Gu.Roslyn.AnalyzerExtensions.QualifiedOverload.QualifiedOverload(Gu.Roslyn.AnalyzerExtensions.QualifiedType containingType, string name, System.Collections.Immutable.ImmutableArray<Gu.Roslyn.AnalyzerExtensions.QualifiedParameter> parameters) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedParameter
Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.Equals(Gu.Roslyn.AnalyzerExtensions.QualifiedParameter other) -> bool
Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.Name.get -> string
Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.QualifiedParameter() -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.QualifiedParameter(string name, Gu.Roslyn.AnalyzerExtensions.QualifiedType type) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.Type.get -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
Gu.Roslyn.AnalyzerExtensions.QualifiedProperty
Gu.Roslyn.AnalyzerExtensions.QualifiedProperty.QualifiedProperty(Gu.Roslyn.AnalyzerExtensions.QualifiedType containingType, string name) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedType
Gu.Roslyn.AnalyzerExtensions.QualifiedType.Alias.get -> string
Gu.Roslyn.AnalyzerExtensions.QualifiedType.FullName.get -> string
Gu.Roslyn.AnalyzerExtensions.QualifiedType.Namespace.get -> Gu.Roslyn.AnalyzerExtensions.NamespaceParts
Gu.Roslyn.AnalyzerExtensions.QualifiedType.QualifiedType(string fullName, Gu.Roslyn.AnalyzerExtensions.NamespaceParts namespace, string type, string alias = null) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedType.QualifiedType(string fullName, string alias = null) -> void
Gu.Roslyn.AnalyzerExtensions.QualifiedType.System
Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.CodeDom
Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.CodeDom.Compiler
Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.Linq
Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.Runtime
Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.Runtime.CompilerServices
Gu.Roslyn.AnalyzerExtensions.QualifiedType.Type.get -> string
Gu.Roslyn.AnalyzerExtensions.Scope
Gu.Roslyn.AnalyzerExtensions.Scope.Instance = 1 -> Gu.Roslyn.AnalyzerExtensions.Scope
Gu.Roslyn.AnalyzerExtensions.Scope.Member = 0 -> Gu.Roslyn.AnalyzerExtensions.Scope
Gu.Roslyn.AnalyzerExtensions.Scope.Recursive = 3 -> Gu.Roslyn.AnalyzerExtensions.Scope
Gu.Roslyn.AnalyzerExtensions.Scope.Type = 2 -> Gu.Roslyn.AnalyzerExtensions.Scope
Gu.Roslyn.AnalyzerExtensions.ScopeExt
Gu.Roslyn.AnalyzerExtensions.Search
Gu.Roslyn.AnalyzerExtensions.Search.Recursive = 1 -> Gu.Roslyn.AnalyzerExtensions.Search
Gu.Roslyn.AnalyzerExtensions.Search.TopLevel = 0 -> Gu.Roslyn.AnalyzerExtensions.Search
Gu.Roslyn.AnalyzerExtensions.SemanticModelCacheAnalyzer
Gu.Roslyn.AnalyzerExtensions.SemanticModelCacheAnalyzer.SemanticModelCacheAnalyzer() -> void
Gu.Roslyn.AnalyzerExtensions.SemanticModelExt
Gu.Roslyn.AnalyzerExtensions.StatementSyntaxExt
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(bool value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(byte value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(char value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(char value, int repeatCount) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(char[] value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(char[] value, int startIndex, int charCount) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(decimal value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(double value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(float value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(int value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(long value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(object value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(sbyte value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(short value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(string value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(string value, int startIndex, int count) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(uint value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(ulong value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Append(ushort value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.AppendFormat(System.IFormatProvider provider, string format, object arg0) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.AppendFormat(System.IFormatProvider provider, string format, params object[] args) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.AppendFormat(string format, object arg0) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.AppendFormat(string format, object arg0, object arg1) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.AppendFormat(string format, object arg0, object arg1, object arg2) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.AppendFormat(string format, params object[] args) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.AppendLine() -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.AppendLine(string value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Capacity.get -> int
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Capacity.set -> void
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Clear() -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) -> void
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.EnsureCapacity(int capacity) -> int
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, bool value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, byte value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, char value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, char[] value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, char[] value, int startIndex, int charCount) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, decimal value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, double value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, float value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, int value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, long value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, object value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, sbyte value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, short value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, string value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, string value, int count) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, uint value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, ulong value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Insert(int index, ushort value) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Length.get -> int
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Length.set -> void
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.MaxCapacity.get -> int
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.PooledStringBuilder() -> void
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Remove(int startIndex, int length) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Replace(char oldChar, char newChar) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Replace(char oldChar, char newChar, int startIndex, int count) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Replace(string oldValue, string newValue) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Replace(string oldValue, string newValue, int startIndex, int count) -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.Return() -> string
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.this[int index].get -> char
Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.this[int index].set -> void
Gu.Roslyn.AnalyzerExtensions.StringHelper
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.ConstructorDeclarationComparer
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.ConstructorDeclarationComparer.ConstructorDeclarationComparer() -> void
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.FieldDeclarationComparer
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.FieldDeclarationComparer.FieldDeclarationComparer() -> void
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.IndexerDeclarationComparer
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.IndexerDeclarationComparer.IndexerDeclarationComparer() -> void
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.MemberDeclarationComparer
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.MemberDeclarationComparer.MemberDeclarationComparer() -> void
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.MethodDeclarationComparer
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.MethodDeclarationComparer.MethodDeclarationComparer() -> void
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.PropertyDeclarationComparer
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.PropertyDeclarationComparer.PropertyDeclarationComparer() -> void
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.UsingDirectiveComparer
Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.UsingDirectiveComparer.UsingDirectiveComparer() -> void
Gu.Roslyn.AnalyzerExtensions.SymbolComparer
Gu.Roslyn.AnalyzerExtensions.SymbolComparer.GetHashCode(Microsoft.CodeAnalysis.ISymbol obj) -> int
Gu.Roslyn.AnalyzerExtensions.SyntaxNodeAnalysisContextExt
Gu.Roslyn.AnalyzerExtensions.SyntaxNodeExt
Gu.Roslyn.AnalyzerExtensions.SyntaxTokenExt
Gu.Roslyn.AnalyzerExtensions.SyntaxTokenListExt
Gu.Roslyn.AnalyzerExtensions.TypeDeclarationSyntaxExt
Gu.Roslyn.AnalyzerExtensions.TypeSymbolComparer
Gu.Roslyn.AnalyzerExtensions.TypeSyntaxExt
Gu.Roslyn.AnalyzerExtensions.VariableDeclarationSyntaxExt
Gu.Roslyn.AnalyzerExtensions.VariableDeclaratorWalker
Gu.Roslyn.AnalyzerExtensions.VariableDeclaratorWalker.RemoveAll(System.Predicate<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax> match) -> void
Gu.Roslyn.AnalyzerExtensions.VariableDeclaratorWalker.VariableDeclarators.get -> System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax>
Gu.Roslyn.AnalyzerExtensions.XmlElementSyntaxExtensions
abstract Gu.Roslyn.AnalyzerExtensions.PooledWalker<T>.Clear() -> void
override Gu.Roslyn.AnalyzerExtensions.AliasWalker.VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.AliasWalker.VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.AliasWalker.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker.VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker.VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.Clear() -> void
override Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.IdentifierNameExecutionWalker.VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.IdentifierTokenWalker.VisitToken(Microsoft.CodeAnalysis.SyntaxToken token) -> void
override Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker.Visit(Microsoft.CodeAnalysis.SyntaxNode node) -> void
override Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker.VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.MutationWalker.VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.MutationWalker.VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.MutationWalker.VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.MutationWalker.VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.NamespaceParts.Equals(object obj) -> bool
override Gu.Roslyn.AnalyzerExtensions.NamespaceParts.GetHashCode() -> int
override Gu.Roslyn.AnalyzerExtensions.NullCheckWalker.VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.NullCheckWalker.VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.NullCheckWalker.VisitIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax node) -> void
override Gu.Roslyn.AnalyzerExtensions.QualifiedArrayType.GetTypeSymbol(Microsoft.CodeAnalysis.Compilation compilation) -> Microsoft.CodeAnalysis.ITypeSymbol
override Gu.Roslyn.AnalyzerExtensions.QualifiedGenericType.GetTypeSymbol(Microsoft.CodeAnalysis.Compilation compilation) -> Microsoft.CodeAnalysis.ITypeSymbol
override Gu.Roslyn.AnalyzerExtensions.QualifiedOverload.Equals(Microsoft.CodeAnalysis.IMethodSymbol symbol) -> bool
override Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.Equals(object obj) -> bool
override Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.GetHashCode() -> int
override Gu.Roslyn.AnalyzerExtensions.QualifiedType.Equals(object obj) -> bool
override Gu.Roslyn.AnalyzerExtensions.QualifiedType.GetHashCode() -> int
override Gu.Roslyn.AnalyzerExtensions.SemanticModelCacheAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext context) -> void
override Gu.Roslyn.AnalyzerExtensions.SemanticModelCacheAnalyzer.SupportedDiagnostics.get -> System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.DiagnosticDescriptor>
override Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder.ToString() -> string
override Gu.Roslyn.AnalyzerExtensions.VariableDeclaratorWalker.VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax node) -> void
static Gu.Roslyn.AnalyzerExtensions.AccessibilityExt.IsEither(this Microsoft.CodeAnalysis.Accessibility accessibility, Microsoft.CodeAnalysis.Accessibility x, Microsoft.CodeAnalysis.Accessibility y) -> bool
static Gu.Roslyn.AnalyzerExtensions.AccessibilityExt.IsEither(this Microsoft.CodeAnalysis.Accessibility accessibility, Microsoft.CodeAnalysis.Accessibility x, Microsoft.CodeAnalysis.Accessibility y, Microsoft.CodeAnalysis.Accessibility z) -> bool
static Gu.Roslyn.AnalyzerExtensions.AccessibilityExt.ToCodeString(this Microsoft.CodeAnalysis.Accessibility accessibility) -> string
static Gu.Roslyn.AnalyzerExtensions.AliasWalker.Borrow(Microsoft.CodeAnalysis.SyntaxNode node) -> Gu.Roslyn.AnalyzerExtensions.AliasWalker
static Gu.Roslyn.AnalyzerExtensions.AliasWalker.TryGet(Microsoft.CodeAnalysis.SyntaxTree tree, string typeName, out Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ArgumentListSyntaxExt.TryFind(this Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList, Microsoft.CodeAnalysis.IParameterSymbol parameter, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument) -> bool
static Gu.Roslyn.AnalyzerExtensions.ArgumentListSyntaxExt.TryFindByNameColon(this Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList, string name, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument) -> bool
static Gu.Roslyn.AnalyzerExtensions.ArgumentSyntaxExt.TryFindParameter(this Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, out Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter) -> bool
static Gu.Roslyn.AnalyzerExtensions.ArgumentSyntaxExt.TryFindParameter(this Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument, Microsoft.CodeAnalysis.IMethodSymbol method, out Microsoft.CodeAnalysis.IParameterSymbol parameter) -> bool
static Gu.Roslyn.AnalyzerExtensions.ArgumentSyntaxExt.TryGetStringValue(this Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out string result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ArgumentSyntaxExt.TryGetTypeofValue(this Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ITypeSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.AssemblySymbolComparer.Equals(Microsoft.CodeAnalysis.IAssemblySymbol x, Microsoft.CodeAnalysis.IAssemblySymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.AssemblySymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker.Borrow(Microsoft.CodeAnalysis.SyntaxNode node, Gu.Roslyn.AnalyzerExtensions.Scope scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker
static Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker.FirstFor(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SyntaxNode node, Gu.Roslyn.AnalyzerExtensions.Scope scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax assignment) -> bool
static Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker.FirstWith(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SyntaxNode node, Gu.Roslyn.AnalyzerExtensions.Scope scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax assignment) -> bool
static Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker.For(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SyntaxNode node, Gu.Roslyn.AnalyzerExtensions.Scope scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker
static Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker.SingleFor(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SyntaxNode node, Gu.Roslyn.AnalyzerExtensions.Scope scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax assignment) -> bool
static Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker.With(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SyntaxNode node, Gu.Roslyn.AnalyzerExtensions.Scope scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.AssignmentExecutionWalker
static Gu.Roslyn.AnalyzerExtensions.Attribute.IsType(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryFind(Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declaration, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryFind(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declaration, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryFind(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax compilation, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryFind(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declaration, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryFind(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax declaration, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryFind(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax declaration, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryFind(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declaration, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryFind(Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax typeDeclaration, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryFind(this Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryFindArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, int argumentIndex, string argumentName, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax argument) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TryGetTypeName(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, out string name) -> bool
static Gu.Roslyn.AnalyzerExtensions.Attribute.TrySingleArgument(this Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, out Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax argument) -> bool
static Gu.Roslyn.AnalyzerExtensions.BaseMethodDeclarationSyntaxExt.Accessibility(this Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declaration) -> Microsoft.CodeAnalysis.Accessibility
static Gu.Roslyn.AnalyzerExtensions.BaseMethodDeclarationSyntaxExt.TryFindParameter(this Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument, out Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter) -> bool
static Gu.Roslyn.AnalyzerExtensions.BaseMethodDeclarationSyntaxExt.TryFindParameter(this Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, string name, out Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter) -> bool
static Gu.Roslyn.AnalyzerExtensions.BasePropertyDeclarationSyntaxExt.Accessibility(this Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declaration) -> Microsoft.CodeAnalysis.Accessibility
static Gu.Roslyn.AnalyzerExtensions.BasePropertyDeclarationSyntaxExt.IsAutoProperty(this Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax property) -> bool
static Gu.Roslyn.AnalyzerExtensions.BasePropertyDeclarationSyntaxExt.IsGetOnly(this Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax property) -> bool
static Gu.Roslyn.AnalyzerExtensions.BasePropertyDeclarationSyntaxExt.TryGetGetter(this Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax property, out Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.BasePropertyDeclarationSyntaxExt.TryGetSetter(this Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax property, out Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.BlockSyntaxExt.ContainsGoto(this Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) -> bool
static Gu.Roslyn.AnalyzerExtensions.Cache.CacheToCompilationEnd<TKey, TValue>(this Microsoft.CodeAnalysis.Diagnostics.AnalysisContext context) -> void
static Gu.Roslyn.AnalyzerExtensions.Cache.GetOrAdd<TKey, TValue>(TKey key, System.Func<TKey, TValue> valueFactory) -> TValue
static Gu.Roslyn.AnalyzerExtensions.Cache<TKey, TValue>.Begin() -> void
static Gu.Roslyn.AnalyzerExtensions.Cache<TKey, TValue>.End() -> void
static Gu.Roslyn.AnalyzerExtensions.Cache<TKey, TValue>.GetOrAdd(TKey key, System.Func<TKey, TValue> valueFactory) -> TValue
static Gu.Roslyn.AnalyzerExtensions.Cache<TKey, TValue>.Transaction() -> Gu.Roslyn.AnalyzerExtensions.Cache<TKey, TValue>.Transaction_
static Gu.Roslyn.AnalyzerExtensions.Constructor.TryFindDefault(Microsoft.CodeAnalysis.INamedTypeSymbol type, Gu.Roslyn.AnalyzerExtensions.Search search, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ConstructorInitializerSyntaxExt.TryFindArgument(this Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.IParameterSymbol parameter, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument) -> bool
static Gu.Roslyn.AnalyzerExtensions.ConstructorInitializerSyntaxExt.TryGetTargetDeclaration(this Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax invocation, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.DiagnosticDescriptorExt.IsSuppressed(this Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.SemanticModel semanticModel) -> bool
static Gu.Roslyn.AnalyzerExtensions.DocumentationCommentTriviaSyntaxExtensions.TryGetParam(this Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax comment, string parameterName, out Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax element) -> bool
static Gu.Roslyn.AnalyzerExtensions.DocumentationCommentTriviaSyntaxExtensions.TryGetReturns(this Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax comment, out Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax element) -> bool
static Gu.Roslyn.AnalyzerExtensions.DocumentationCommentTriviaSyntaxExtensions.TryGetSummary(this Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax comment, out Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax element) -> bool
static Gu.Roslyn.AnalyzerExtensions.DocumentationCommentTriviaSyntaxExtensions.TryGetTypeParam(this Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax comment, string parameterName, out Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax element) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryElementAt(this Microsoft.CodeAnalysis.ChildSyntaxList source, int index, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryElementAt(this Microsoft.CodeAnalysis.SyntaxNodeOrTokenList source, int index, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryElementAt(this Microsoft.CodeAnalysis.SyntaxTokenList source, int index, out Microsoft.CodeAnalysis.SyntaxToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryElementAt(this Microsoft.CodeAnalysis.SyntaxTriviaList source, int index, out Microsoft.CodeAnalysis.SyntaxTrivia result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryElementAt<T>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, int index, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryElementAt<T>(this Microsoft.CodeAnalysis.SyntaxList<T> source, int index, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryElementAt<T>(this System.Collections.Generic.IEnumerable<T> source, int index, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryElementAt<T>(this System.Collections.Generic.IReadOnlyList<T> source, int index, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryElementAt<T>(this System.Collections.Immutable.ImmutableArray<T> source, int index, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst(this Microsoft.CodeAnalysis.ChildSyntaxList source, System.Func<Microsoft.CodeAnalysis.SyntaxNodeOrToken, bool> predicate, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst(this Microsoft.CodeAnalysis.ChildSyntaxList source, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst(this Microsoft.CodeAnalysis.SyntaxNodeOrTokenList source, System.Func<Microsoft.CodeAnalysis.SyntaxNodeOrToken, bool> predicate, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst(this Microsoft.CodeAnalysis.SyntaxNodeOrTokenList source, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst(this Microsoft.CodeAnalysis.SyntaxTokenList source, System.Func<Microsoft.CodeAnalysis.SyntaxToken, bool> predicate, out Microsoft.CodeAnalysis.SyntaxToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst(this Microsoft.CodeAnalysis.SyntaxTokenList source, out Microsoft.CodeAnalysis.SyntaxToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst(this Microsoft.CodeAnalysis.SyntaxTriviaList source, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, bool> predicate, out Microsoft.CodeAnalysis.SyntaxTrivia result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst(this Microsoft.CodeAnalysis.SyntaxTriviaList source, out Microsoft.CodeAnalysis.SyntaxTrivia result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst<T>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst<T>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst<T>(this Microsoft.CodeAnalysis.SyntaxList<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst<T>(this Microsoft.CodeAnalysis.SyntaxList<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst<T>(this System.Collections.Generic.IEnumerable<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst<T>(this System.Collections.Generic.IEnumerable<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst<T>(this System.Collections.Generic.IReadOnlyList<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst<T>(this System.Collections.Generic.IReadOnlyList<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst<T>(this System.Collections.Immutable.ImmutableArray<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirst<T>(this System.Collections.Immutable.ImmutableArray<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirstOfType<T, TResult>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirstOfType<T, TResult>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirstOfType<T, TResult>(this Microsoft.CodeAnalysis.SyntaxList<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirstOfType<T, TResult>(this Microsoft.CodeAnalysis.SyntaxList<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirstOfType<T, TResult>(this System.Collections.Generic.IEnumerable<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirstOfType<T, TResult>(this System.Collections.Generic.IEnumerable<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirstOfType<T, TResult>(this System.Collections.Generic.IReadOnlyList<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirstOfType<T, TResult>(this System.Collections.Generic.IReadOnlyList<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirstOfType<T, TResult>(this System.Collections.Immutable.ImmutableArray<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryFirstOfType<T, TResult>(this System.Collections.Immutable.ImmutableArray<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast(this Microsoft.CodeAnalysis.ChildSyntaxList source, System.Func<Microsoft.CodeAnalysis.SyntaxNodeOrToken, bool> predicate, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast(this Microsoft.CodeAnalysis.ChildSyntaxList source, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast(this Microsoft.CodeAnalysis.SyntaxNodeOrTokenList source, System.Func<Microsoft.CodeAnalysis.SyntaxNodeOrToken, bool> predicate, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast(this Microsoft.CodeAnalysis.SyntaxNodeOrTokenList source, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast(this Microsoft.CodeAnalysis.SyntaxTokenList source, System.Func<Microsoft.CodeAnalysis.SyntaxToken, bool> predicate, out Microsoft.CodeAnalysis.SyntaxToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast(this Microsoft.CodeAnalysis.SyntaxTokenList source, out Microsoft.CodeAnalysis.SyntaxToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast(this Microsoft.CodeAnalysis.SyntaxTriviaList source, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, bool> predicate, out Microsoft.CodeAnalysis.SyntaxTrivia result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast(this Microsoft.CodeAnalysis.SyntaxTriviaList source, out Microsoft.CodeAnalysis.SyntaxTrivia result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast<T>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast<T>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast<T>(this Microsoft.CodeAnalysis.SyntaxList<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast<T>(this Microsoft.CodeAnalysis.SyntaxList<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast<T>(this System.Collections.Generic.IEnumerable<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast<T>(this System.Collections.Generic.IEnumerable<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast<T>(this System.Collections.Generic.IReadOnlyList<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast<T>(this System.Collections.Generic.IReadOnlyList<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast<T>(this System.Collections.Immutable.ImmutableArray<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLast<T>(this System.Collections.Immutable.ImmutableArray<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLastOfType<T, TResult>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLastOfType<T, TResult>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLastOfType<T, TResult>(this Microsoft.CodeAnalysis.SyntaxList<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLastOfType<T, TResult>(this Microsoft.CodeAnalysis.SyntaxList<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLastOfType<T, TResult>(this System.Collections.Generic.IEnumerable<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLastOfType<T, TResult>(this System.Collections.Generic.IEnumerable<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLastOfType<T, TResult>(this System.Collections.Generic.IReadOnlyList<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLastOfType<T, TResult>(this System.Collections.Generic.IReadOnlyList<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLastOfType<T, TResult>(this System.Collections.Immutable.ImmutableArray<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TryLastOfType<T, TResult>(this System.Collections.Immutable.ImmutableArray<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle(this Microsoft.CodeAnalysis.ChildSyntaxList source, System.Func<Microsoft.CodeAnalysis.SyntaxNodeOrToken, bool> predicate, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle(this Microsoft.CodeAnalysis.ChildSyntaxList source, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle(this Microsoft.CodeAnalysis.SyntaxNodeOrTokenList source, System.Func<Microsoft.CodeAnalysis.SyntaxNodeOrToken, bool> predicate, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle(this Microsoft.CodeAnalysis.SyntaxNodeOrTokenList source, out Microsoft.CodeAnalysis.SyntaxNodeOrToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle(this Microsoft.CodeAnalysis.SyntaxTokenList source, System.Func<Microsoft.CodeAnalysis.SyntaxToken, bool> predicate, out Microsoft.CodeAnalysis.SyntaxToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle(this Microsoft.CodeAnalysis.SyntaxTokenList source, out Microsoft.CodeAnalysis.SyntaxToken result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle(this Microsoft.CodeAnalysis.SyntaxTriviaList source, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, bool> predicate, out Microsoft.CodeAnalysis.SyntaxTrivia result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle(this Microsoft.CodeAnalysis.SyntaxTriviaList source, out Microsoft.CodeAnalysis.SyntaxTrivia result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle<T>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle<T>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle<T>(this Microsoft.CodeAnalysis.SyntaxList<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle<T>(this Microsoft.CodeAnalysis.SyntaxList<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle<T>(this System.Collections.Generic.IEnumerable<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle<T>(this System.Collections.Generic.IEnumerable<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle<T>(this System.Collections.Generic.IReadOnlyList<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle<T>(this System.Collections.Generic.IReadOnlyList<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle<T>(this System.Collections.Immutable.ImmutableArray<T> source, System.Func<T, bool> predicate, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingle<T>(this System.Collections.Immutable.ImmutableArray<T> source, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingleOfType<T, TResult>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingleOfType<T, TResult>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingleOfType<T, TResult>(this Microsoft.CodeAnalysis.SyntaxList<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingleOfType<T, TResult>(this Microsoft.CodeAnalysis.SyntaxList<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingleOfType<T, TResult>(this System.Collections.Generic.IEnumerable<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingleOfType<T, TResult>(this System.Collections.Generic.IEnumerable<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingleOfType<T, TResult>(this System.Collections.Generic.IReadOnlyList<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingleOfType<T, TResult>(this System.Collections.Generic.IReadOnlyList<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingleOfType<T, TResult>(this System.Collections.Immutable.ImmutableArray<T> source, System.Func<TResult, bool> predicate, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EnumerableExt.TrySingleOfType<T, TResult>(this System.Collections.Immutable.ImmutableArray<T> source, out TResult result) -> bool
static Gu.Roslyn.AnalyzerExtensions.EventSymbolComparer.Equals(Microsoft.CodeAnalysis.IEventSymbol x, Microsoft.CodeAnalysis.IEventSymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.EventSymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.ExecutedBeforeExt.IsEither(this Gu.Roslyn.AnalyzerExtensions.ExecutedBefore candidate, Gu.Roslyn.AnalyzerExtensions.ExecutedBefore x, Gu.Roslyn.AnalyzerExtensions.ExecutedBefore y) -> bool
static Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.BorrowAndVisit(Microsoft.CodeAnalysis.SyntaxNode node, Gu.Roslyn.AnalyzerExtensions.Scope scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, System.Func<T> create) -> T
static Gu.Roslyn.AnalyzerExtensions.ExpressionSyntaxExt.IsAssignableTo(this Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Gu.Roslyn.AnalyzerExtensions.QualifiedType destination, Microsoft.CodeAnalysis.SemanticModel semanticModel) -> bool
static Gu.Roslyn.AnalyzerExtensions.ExpressionSyntaxExt.IsAssignableTo(this Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, Microsoft.CodeAnalysis.SemanticModel semanticModel) -> bool
static Gu.Roslyn.AnalyzerExtensions.ExpressionSyntaxExt.IsExecutedBefore(this Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax other) -> Gu.Roslyn.AnalyzerExtensions.ExecutedBefore
static Gu.Roslyn.AnalyzerExtensions.ExpressionSyntaxExt.IsExecutedBefore(this Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax other) -> Gu.Roslyn.AnalyzerExtensions.ExecutedBefore
static Gu.Roslyn.AnalyzerExtensions.ExpressionSyntaxExt.IsRepresentationPreservingConversion(this Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> bool
static Gu.Roslyn.AnalyzerExtensions.ExpressionSyntaxExt.IsSameType(this Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Gu.Roslyn.AnalyzerExtensions.QualifiedType destination, Microsoft.CodeAnalysis.SemanticModel semanticModel) -> bool
static Gu.Roslyn.AnalyzerExtensions.ExpressionSyntaxExt.IsSameType(this Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, Microsoft.CodeAnalysis.SemanticModel semanticModel) -> bool
static Gu.Roslyn.AnalyzerExtensions.FieldDeclarationSyntaxExt.Accessibility(this Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax declaration) -> Microsoft.CodeAnalysis.Accessibility
static Gu.Roslyn.AnalyzerExtensions.FieldDeclarationSyntaxExt.TryFindVariable(this Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax fieldDeclaration, string name, out Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.FieldDeclarationSyntaxExt.TryGetName(this Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax declaration, out string name) -> bool
static Gu.Roslyn.AnalyzerExtensions.FieldOrProperty.TryCreate(Microsoft.CodeAnalysis.ISymbol symbol, out Gu.Roslyn.AnalyzerExtensions.FieldOrProperty result) -> bool
static Gu.Roslyn.AnalyzerExtensions.FieldSymbolComparer.Equals(Microsoft.CodeAnalysis.IFieldSymbol x, Microsoft.CodeAnalysis.IFieldSymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.FieldSymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.ILocalSymbolExt.TryGetScope(this Microsoft.CodeAnalysis.ILocalSymbol local, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.SyntaxNode scope) -> bool
static Gu.Roslyn.AnalyzerExtensions.IMethodSymbolExt.TryFindParameter(this Microsoft.CodeAnalysis.IMethodSymbol method, Gu.Roslyn.AnalyzerExtensions.QualifiedType type, out Microsoft.CodeAnalysis.IParameterSymbol parameter) -> bool
static Gu.Roslyn.AnalyzerExtensions.IMethodSymbolExt.TryFindParameter(this Microsoft.CodeAnalysis.IMethodSymbol method, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument, out Microsoft.CodeAnalysis.IParameterSymbol parameter) -> bool
static Gu.Roslyn.AnalyzerExtensions.IMethodSymbolExt.TryFindParameter(this Microsoft.CodeAnalysis.IMethodSymbol method, string name, out Microsoft.CodeAnalysis.IParameterSymbol parameter) -> bool
static Gu.Roslyn.AnalyzerExtensions.INamedTypeSymbolExtensions.FullName(this Microsoft.CodeAnalysis.INamedTypeSymbol type) -> string
static Gu.Roslyn.AnalyzerExtensions.IParameterSymbolExt.IsCallerMemberName(this Microsoft.CodeAnalysis.IParameterSymbol parameter) -> bool
static Gu.Roslyn.AnalyzerExtensions.IPropertySymbolExt.IsAutoProperty(this Microsoft.CodeAnalysis.IPropertySymbol property) -> bool
static Gu.Roslyn.AnalyzerExtensions.IPropertySymbolExt.IsGetOnly(this Microsoft.CodeAnalysis.IPropertySymbol property) -> bool
static Gu.Roslyn.AnalyzerExtensions.IPropertySymbolExt.TryGetGetMethodDeclaration(this Microsoft.CodeAnalysis.IPropertySymbol property, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.SyntaxNode declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.IPropertySymbolExt.TryGetGetter(this Microsoft.CodeAnalysis.IPropertySymbol property, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax getter) -> bool
static Gu.Roslyn.AnalyzerExtensions.IPropertySymbolExt.TryGetSetter(this Microsoft.CodeAnalysis.IPropertySymbol property, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax setter) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.HasCompilerGeneratedAttribute(this Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.HasGeneratedCodeAttribute(this Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.IsEither<T1, T2, T3>(this Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.IsEither<T1, T2>(this Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.IsEitherKind(this Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SymbolKind kind1, Microsoft.CodeAnalysis.SymbolKind kind2) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.IsEitherKind(this Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SymbolKind kind1, Microsoft.CodeAnalysis.SymbolKind kind2, Microsoft.CodeAnalysis.SymbolKind kind3) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.IsEquivalentTo(this Microsoft.CodeAnalysis.ISymbol x, Microsoft.CodeAnalysis.ISymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.TryGetAttribute(this Microsoft.CodeAnalysis.ISymbol symbol, Gu.Roslyn.AnalyzerExtensions.QualifiedType attributeType, out Microsoft.CodeAnalysis.AttributeData attribute) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.TrySingleAccessorDeclaration(this Microsoft.CodeAnalysis.IMethodSymbol method, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.TrySingleDeclaration(this Microsoft.CodeAnalysis.IFieldSymbol field, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.TrySingleDeclaration(this Microsoft.CodeAnalysis.ILocalSymbol local, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.SyntaxNode declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.TrySingleDeclaration(this Microsoft.CodeAnalysis.IParameterSymbol parameter, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.TrySingleDeclaration(this Microsoft.CodeAnalysis.IPropertySymbol property, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.TrySingleDeclaration<T>(this Microsoft.CodeAnalysis.IMethodSymbol method, System.Threading.CancellationToken cancellationToken, out T declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.TrySingleDeclaration<T>(this Microsoft.CodeAnalysis.ISymbol symbol, System.Threading.CancellationToken cancellationToken, out T declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.ISymbolExt.TrySingleMethodDeclaration(this Microsoft.CodeAnalysis.IMethodSymbol method, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.Is(this Microsoft.CodeAnalysis.ITypeSymbol source, Gu.Roslyn.AnalyzerExtensions.QualifiedType qualifiedType) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.Is(this Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsAssignableTo(this Microsoft.CodeAnalysis.ITypeSymbol source, Gu.Roslyn.AnalyzerExtensions.QualifiedType destination, Microsoft.CodeAnalysis.Compilation compilation) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsAssignableTo(this Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination, Microsoft.CodeAnalysis.Compilation compilation) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsAssignableToEither(this Microsoft.CodeAnalysis.ITypeSymbol type, Gu.Roslyn.AnalyzerExtensions.QualifiedType qualifiedType1, Gu.Roslyn.AnalyzerExtensions.QualifiedType qualifiedType2, Microsoft.CodeAnalysis.Compilation compilation) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsAwaitable(this Microsoft.CodeAnalysis.ITypeSymbol type) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsEither(this Microsoft.CodeAnalysis.ITypeSymbol type, Gu.Roslyn.AnalyzerExtensions.QualifiedType qualifiedType1, Gu.Roslyn.AnalyzerExtensions.QualifiedType qualifiedType2) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsEither(this Microsoft.CodeAnalysis.ITypeSymbol type, Gu.Roslyn.AnalyzerExtensions.QualifiedType qualifiedType1, Gu.Roslyn.AnalyzerExtensions.QualifiedType qualifiedType2, Gu.Roslyn.AnalyzerExtensions.QualifiedType qualifiedType3) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsNullable(this Microsoft.CodeAnalysis.INamedTypeSymbol nullableType, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsNullable(this Microsoft.CodeAnalysis.ITypeSymbol nullableType, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsSameType(this Microsoft.CodeAnalysis.INamedTypeSymbol x, Microsoft.CodeAnalysis.INamedTypeSymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsSameType(this Microsoft.CodeAnalysis.ITypeSymbol source, Gu.Roslyn.AnalyzerExtensions.QualifiedType destination, Microsoft.CodeAnalysis.Compilation compilation) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsSameType(this Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination, Microsoft.CodeAnalysis.Compilation compilation) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.IsSameType(this Microsoft.CodeAnalysis.ITypeSymbol x, Microsoft.CodeAnalysis.ITypeSymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindEvent(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.IEventSymbol event) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindEventRecursive(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.IEventSymbol event) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindField(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.IFieldSymbol field) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFieldRecursive(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.IFieldSymbol field) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMember(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.ISymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMember<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, System.Func<TMember, bool> predicate, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMember<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, System.Func<TMember, bool> predicate, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMember<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMemberRecursive(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.ISymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMemberRecursive<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, System.Func<TMember, bool> predicate, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMemberRecursive<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, System.Func<TMember, bool> predicate, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMemberRecursive<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMethod(this Microsoft.CodeAnalysis.ITypeSymbol type, System.Func<Microsoft.CodeAnalysis.IMethodSymbol, bool> predicate, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMethod(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, System.Func<Microsoft.CodeAnalysis.IMethodSymbol, bool> predicate, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMethod(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMethodRecursive(this Microsoft.CodeAnalysis.ITypeSymbol type, System.Func<Microsoft.CodeAnalysis.IMethodSymbol, bool> predicate, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMethodRecursive(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, System.Func<Microsoft.CodeAnalysis.IMethodSymbol, bool> predicate, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindFirstMethodRecursive(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindProperty(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.IPropertySymbol property) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindPropertyRecursive(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.IPropertySymbol property) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMember<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, System.Func<TMember, bool> predicate, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMember<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, System.Func<TMember, bool> predicate, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMember<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMemberRecursive<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, System.Func<TMember, bool> predicate, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMemberRecursive<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, System.Func<TMember, bool> predicate, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMemberRecursive<TMember>(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out TMember member) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMethod(this Microsoft.CodeAnalysis.ITypeSymbol type, System.Func<Microsoft.CodeAnalysis.IMethodSymbol, bool> predicate, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMethod(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, System.Func<Microsoft.CodeAnalysis.IMethodSymbol, bool> predicate, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMethod(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMethodRecursive(this Microsoft.CodeAnalysis.ITypeSymbol type, System.Func<Microsoft.CodeAnalysis.IMethodSymbol, bool> predicate, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMethodRecursive(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, System.Func<Microsoft.CodeAnalysis.IMethodSymbol, bool> predicate, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.ITypeSymbolExt.TryFindSingleMethodRecursive(this Microsoft.CodeAnalysis.ITypeSymbol type, string name, out Microsoft.CodeAnalysis.IMethodSymbol result) -> bool
static Gu.Roslyn.AnalyzerExtensions.IdentifierNameExecutionWalker.Borrow(Microsoft.CodeAnalysis.SyntaxNode node, Gu.Roslyn.AnalyzerExtensions.Scope scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.IdentifierNameExecutionWalker
static Gu.Roslyn.AnalyzerExtensions.IdentifierNameSyntaxExtensions.IsSymbol(this Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax candidate, Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> bool
static Gu.Roslyn.AnalyzerExtensions.IdentifierNameSyntaxExtensions.TryGetTarget(this Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax candidate, Gu.Roslyn.AnalyzerExtensions.QualifiedField expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IFieldSymbol target) -> bool
static Gu.Roslyn.AnalyzerExtensions.IdentifierNameSyntaxExtensions.TryGetTarget(this Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax candidate, Gu.Roslyn.AnalyzerExtensions.QualifiedProperty expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IPropertySymbol target) -> bool
static Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.Borrow(Microsoft.CodeAnalysis.SyntaxNode node) -> Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker
static Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.For(Gu.Roslyn.AnalyzerExtensions.LocalOrParameter localOrParameter, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker
static Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.For(Microsoft.CodeAnalysis.ILocalSymbol local, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker
static Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.For(Microsoft.CodeAnalysis.IParameterSymbol parameter, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker
static Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.TryFindFirst(Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifierName) -> bool
static Gu.Roslyn.AnalyzerExtensions.IdentifierNameWalker.TryFindLast(Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifierName) -> bool
static Gu.Roslyn.AnalyzerExtensions.IdentifierTokenWalker.Borrow(Microsoft.CodeAnalysis.SyntaxNode node) -> Gu.Roslyn.AnalyzerExtensions.IdentifierTokenWalker
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.IsNameOf(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.IsPotentialReturnVoid(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.IsPotentialThis(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.IsPotentialThisOrBase(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.IsTypeOf(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.TryFindArgument(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation, Microsoft.CodeAnalysis.IParameterSymbol parameter, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.TryGetMethodName(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation, out string name) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.TryGetTarget(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation, Gu.Roslyn.AnalyzerExtensions.QualifiedMethod expected, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter qualifiedParameter0, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter qualifiedParameter1, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter qualifiedParameter2, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter qualifiedParameter3, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol target, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument0, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument1, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument2, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument3) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.TryGetTarget(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation, Gu.Roslyn.AnalyzerExtensions.QualifiedMethod expected, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter qualifiedParameter0, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter qualifiedParameter1, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter qualifiedParameter2, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol target, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument0, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument1, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument2) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.TryGetTarget(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation, Gu.Roslyn.AnalyzerExtensions.QualifiedMethod expected, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter qualifiedParameter0, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter qualifiedParameter1, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol target, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument0, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument1) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.TryGetTarget(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation, Gu.Roslyn.AnalyzerExtensions.QualifiedMethod expected, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter qualifiedParameter0, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol target, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.TryGetTarget(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation, Gu.Roslyn.AnalyzerExtensions.QualifiedMethod expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol target) -> bool
static Gu.Roslyn.AnalyzerExtensions.InvocationExpressionSyntaxExt.TryGetTargetDeclaration(this Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax invocation, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.LocalOrParameter.TryCreate(Microsoft.CodeAnalysis.ISymbol symbol, out Gu.Roslyn.AnalyzerExtensions.LocalOrParameter result) -> bool
static Gu.Roslyn.AnalyzerExtensions.LocalSymbolComparer.Equals(Microsoft.CodeAnalysis.ILocalSymbol x, Microsoft.CodeAnalysis.ILocalSymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.LocalSymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberAccessExpressionSyntaxExtensions.TryGetTarget(this Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax candidate, Gu.Roslyn.AnalyzerExtensions.QualifiedField expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IFieldSymbol target) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberAccessExpressionSyntaxExtensions.TryGetTarget(this Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax candidate, Gu.Roslyn.AnalyzerExtensions.QualifiedProperty expected, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IPropertySymbol target) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberDeclarationSyntaxExtensions.LeadingWhitespace(this Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor) -> string
static Gu.Roslyn.AnalyzerExtensions.MemberDeclarationSyntaxExtensions.LeadingWhitespace(this Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax member) -> string
static Gu.Roslyn.AnalyzerExtensions.MemberDeclarationSyntaxExtensions.TryGetDocumentationComment(this Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax member, out Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax comment) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberPath.Equals(Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker x, Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker y) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberPath.Equals(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax x, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax y) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberPath.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberPath.Get(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) -> Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker
static Gu.Roslyn.AnalyzerExtensions.MemberPath.IsEmpty(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker.Borrow(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node) -> Gu.Roslyn.AnalyzerExtensions.MemberPath.PathWalker
static Gu.Roslyn.AnalyzerExtensions.MemberPath.TryFindLast(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, out Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax member) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberPath.TryFindRoot(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, out Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax member) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberPath.TryGetMemberName(this Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, out string name) -> bool
static Gu.Roslyn.AnalyzerExtensions.MemberPath.TrySingle(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, out Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax member) -> bool
static Gu.Roslyn.AnalyzerExtensions.MethodSymbolComparer.Equals(Microsoft.CodeAnalysis.IMethodSymbol x, Microsoft.CodeAnalysis.IMethodSymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.MethodSymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.MutationWalker.Borrow(Microsoft.CodeAnalysis.SyntaxNode node, Gu.Roslyn.AnalyzerExtensions.Scope scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.MutationWalker
static Gu.Roslyn.AnalyzerExtensions.MutationWalker.For(Gu.Roslyn.AnalyzerExtensions.FieldOrProperty fieldOrProperty, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.MutationWalker
static Gu.Roslyn.AnalyzerExtensions.MutationWalker.For(Gu.Roslyn.AnalyzerExtensions.LocalOrParameter localOrParameter, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.MutationWalker
static Gu.Roslyn.AnalyzerExtensions.MutationWalker.For(Microsoft.CodeAnalysis.IFieldSymbol field, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.MutationWalker
static Gu.Roslyn.AnalyzerExtensions.MutationWalker.For(Microsoft.CodeAnalysis.ILocalSymbol local, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.MutationWalker
static Gu.Roslyn.AnalyzerExtensions.MutationWalker.For(Microsoft.CodeAnalysis.IParameterSymbol parameter, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.MutationWalker
static Gu.Roslyn.AnalyzerExtensions.MutationWalker.For(Microsoft.CodeAnalysis.IPropertySymbol property, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.MutationWalker
static Gu.Roslyn.AnalyzerExtensions.MutationWalker.For(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.MutationWalker
static Gu.Roslyn.AnalyzerExtensions.NamedTypeSymbolComparer.Equals(Microsoft.CodeAnalysis.INamedTypeSymbol x, Microsoft.CodeAnalysis.INamedTypeSymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.NamedTypeSymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.NamespaceParts.Create(string fullName) -> Gu.Roslyn.AnalyzerExtensions.NamespaceParts
static Gu.Roslyn.AnalyzerExtensions.NamespaceParts.operator !=(Microsoft.CodeAnalysis.INamespaceSymbol left, Gu.Roslyn.AnalyzerExtensions.NamespaceParts right) -> bool
static Gu.Roslyn.AnalyzerExtensions.NamespaceParts.operator ==(Microsoft.CodeAnalysis.INamespaceSymbol left, Gu.Roslyn.AnalyzerExtensions.NamespaceParts right) -> bool
static Gu.Roslyn.AnalyzerExtensions.NamespaceSymbolComparer.Equals(Microsoft.CodeAnalysis.INamespaceSymbol x, Microsoft.CodeAnalysis.INamespaceSymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.NamespaceSymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.NullCheck.For(Microsoft.CodeAnalysis.IParameterSymbol parameter, Microsoft.CodeAnalysis.SyntaxNode scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> Gu.Roslyn.AnalyzerExtensions.NullCheckWalker
static Gu.Roslyn.AnalyzerExtensions.NullCheck.IsChecked(Microsoft.CodeAnalysis.IParameterSymbol parameter, Microsoft.CodeAnalysis.SyntaxNode scope, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> bool
static Gu.Roslyn.AnalyzerExtensions.NullCheck.IsCheckedBefore(Microsoft.CodeAnalysis.IParameterSymbol parameter, Microsoft.CodeAnalysis.SyntaxNode location, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> bool
static Gu.Roslyn.AnalyzerExtensions.NullCheckWalker.Borrow(Microsoft.CodeAnalysis.SyntaxNode scope) -> Gu.Roslyn.AnalyzerExtensions.NullCheckWalker
static Gu.Roslyn.AnalyzerExtensions.ObjectCreationExpressionSyntaxExt.TryFindArgument(this Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax objectCreation, Microsoft.CodeAnalysis.IParameterSymbol parameter, out Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argument) -> bool
static Gu.Roslyn.AnalyzerExtensions.ObjectCreationExpressionSyntaxExt.TryGetTargetDeclaration(this Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax invocation, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax declaration) -> bool
static Gu.Roslyn.AnalyzerExtensions.ParameterListSyntaxExt.TryFind(this Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, string name, out Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter) -> bool
static Gu.Roslyn.AnalyzerExtensions.ParameterSymbolComparer.Equals(Microsoft.CodeAnalysis.IParameterSymbol x, Microsoft.CodeAnalysis.IParameterSymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.ParameterSymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.PooledDictionary.Borrow<TKey, TValue>() -> Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>
static Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>.Borrow() -> Gu.Roslyn.AnalyzerExtensions.PooledDictionary<TKey, TValue>
static Gu.Roslyn.AnalyzerExtensions.PooledList.Borrow<T>() -> Gu.Roslyn.AnalyzerExtensions.PooledList<T>
static Gu.Roslyn.AnalyzerExtensions.PooledList<T>.Borrow() -> Gu.Roslyn.AnalyzerExtensions.PooledList<T>
static Gu.Roslyn.AnalyzerExtensions.PooledSet.IncrementUsage<T>(this Gu.Roslyn.AnalyzerExtensions.PooledSet<T> set) -> Gu.Roslyn.AnalyzerExtensions.PooledSet<T>
static Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.Borrow() -> Gu.Roslyn.AnalyzerExtensions.PooledSet<T>
static Gu.Roslyn.AnalyzerExtensions.PooledSet<T>.BorrowOrIncrementUsage(Gu.Roslyn.AnalyzerExtensions.PooledSet<T> set) -> Gu.Roslyn.AnalyzerExtensions.PooledSet<T>
static Gu.Roslyn.AnalyzerExtensions.PooledWalker<T>.Borrow(System.Func<T> create) -> T
static Gu.Roslyn.AnalyzerExtensions.PooledWalker<T>.BorrowAndVisit(Microsoft.CodeAnalysis.SyntaxNode node, System.Func<T> create) -> T
static Gu.Roslyn.AnalyzerExtensions.PropertyDeclarationSyntaxExt.TryGetBackingField(this Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax property, out Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax backingField) -> bool
static Gu.Roslyn.AnalyzerExtensions.PropertyDeclarationSyntaxExt.TrySingleReturned(this Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax property, out Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.PropertySymbolComparer.Equals(Microsoft.CodeAnalysis.IPropertySymbol x, Microsoft.CodeAnalysis.IPropertySymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.PropertySymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T>.operator !=(Microsoft.CodeAnalysis.ISymbol left, Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T> right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T>.operator !=(T left, Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T> right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T>.operator ==(Microsoft.CodeAnalysis.ISymbol left, Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T> right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T>.operator ==(T left, Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T> right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.Create(Gu.Roslyn.AnalyzerExtensions.QualifiedType type) -> Gu.Roslyn.AnalyzerExtensions.QualifiedParameter
static Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.Create(string name) -> Gu.Roslyn.AnalyzerExtensions.QualifiedParameter
static Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.operator !=(Microsoft.CodeAnalysis.IParameterSymbol left, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedParameter.operator ==(Microsoft.CodeAnalysis.IParameterSymbol left, Gu.Roslyn.AnalyzerExtensions.QualifiedParameter right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedType.FromType(System.Type type) -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
static Gu.Roslyn.AnalyzerExtensions.QualifiedType.operator !=(Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax left, Gu.Roslyn.AnalyzerExtensions.QualifiedType right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedType.operator !=(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax left, Gu.Roslyn.AnalyzerExtensions.QualifiedType right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedType.operator !=(Microsoft.CodeAnalysis.ITypeSymbol left, Gu.Roslyn.AnalyzerExtensions.QualifiedType right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedType.operator ==(Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax left, Gu.Roslyn.AnalyzerExtensions.QualifiedType right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedType.operator ==(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax left, Gu.Roslyn.AnalyzerExtensions.QualifiedType right) -> bool
static Gu.Roslyn.AnalyzerExtensions.QualifiedType.operator ==(Microsoft.CodeAnalysis.ITypeSymbol left, Gu.Roslyn.AnalyzerExtensions.QualifiedType right) -> bool
static Gu.Roslyn.AnalyzerExtensions.ScopeExt.IsEither(this Gu.Roslyn.AnalyzerExtensions.Scope scope, Gu.Roslyn.AnalyzerExtensions.Scope scope1, Gu.Roslyn.AnalyzerExtensions.Scope scope2) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetConstantValueSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.Optional<object>
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ISymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IMethodSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ISymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ISymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IDiscardSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IEventSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IEventSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IFieldSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IPropertySymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IMethodSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IParameterSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IPropertySymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ILocalSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ITypeSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ISymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ISymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ISymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetDeclaredSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ISymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ISymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IMethodSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ISymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IMethodSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.IMethodSymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetSymbolSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.ISymbol
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.GetTypeInfoSafe(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.TypeInfo
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.IsRepresentationPreservingConversion(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, System.Threading.CancellationToken cancellationToken) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.SemanticModelFor(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode expression) -> Microsoft.CodeAnalysis.SemanticModel
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetConstantValue<T>(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken, out T value) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IDiscardSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IEventSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IEventSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IFieldSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IPropertySymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node, Gu.Roslyn.AnalyzerExtensions.QualifiedMethod expected, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax node, Gu.Roslyn.AnalyzerExtensions.QualifiedType expected, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IMethodSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IParameterSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.IPropertySymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ILocalSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ITypeSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ISymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetSymbol<TSymbol>(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken, out TSymbol symbol) -> bool
static Gu.Roslyn.AnalyzerExtensions.SemanticModelExt.TryGetType(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken, out Microsoft.CodeAnalysis.ITypeSymbol type) -> bool
static Gu.Roslyn.AnalyzerExtensions.StatementSyntaxExt.IsExecutedBefore(this Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax other) -> Gu.Roslyn.AnalyzerExtensions.ExecutedBefore
static Gu.Roslyn.AnalyzerExtensions.StatementSyntaxExt.IsExecutedBefore(this Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax other) -> Gu.Roslyn.AnalyzerExtensions.ExecutedBefore
static Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.Borrow() -> Gu.Roslyn.AnalyzerExtensions.StringBuilderPool.PooledStringBuilder
static Gu.Roslyn.AnalyzerExtensions.StringHelper.IsParts(this string text, string part1, string part2, string part3, string part4, System.StringComparison stringComparison = System.StringComparison.Ordinal) -> bool
static Gu.Roslyn.AnalyzerExtensions.StringHelper.IsParts(this string text, string part1, string part2, string part3, string part4, string part5, System.StringComparison stringComparison = System.StringComparison.Ordinal) -> bool
static Gu.Roslyn.AnalyzerExtensions.StringHelper.IsParts(this string text, string start, string end, System.StringComparison stringComparison = System.StringComparison.Ordinal) -> bool
static Gu.Roslyn.AnalyzerExtensions.StringHelper.IsParts(this string text, string start, string middle, string end, System.StringComparison stringComparison = System.StringComparison.Ordinal) -> bool
static Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.ConstructorDeclarationComparer.Compare(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax x, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax y) -> int
static Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.FieldDeclarationComparer.Compare(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax x, Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax y) -> int
static Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.IndexerDeclarationComparer.Compare(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax x, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax y) -> int
static Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.MemberDeclarationComparer.Compare(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax x, Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax y) -> int
static Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.MethodDeclarationComparer.Compare(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax x, Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax y) -> int
static Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.PropertyDeclarationComparer.Compare(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax x, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax y) -> int
static Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.UsingDirectiveComparer.Compare(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax x, Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax y) -> int
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(Microsoft.CodeAnalysis.IEventSymbol _, Microsoft.CodeAnalysis.IEventSymbol __) -> bool
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(Microsoft.CodeAnalysis.IFieldSymbol _, Microsoft.CodeAnalysis.IFieldSymbol __) -> bool
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(Microsoft.CodeAnalysis.ILocalSymbol _, Microsoft.CodeAnalysis.ILocalSymbol __) -> bool
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(Microsoft.CodeAnalysis.IMethodSymbol _, Microsoft.CodeAnalysis.IMethodSymbol __) -> bool
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(Microsoft.CodeAnalysis.INamedTypeSymbol _, Microsoft.CodeAnalysis.INamedTypeSymbol __) -> bool
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(Microsoft.CodeAnalysis.INamespaceSymbol _, Microsoft.CodeAnalysis.INamespaceSymbol __) -> bool
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(Microsoft.CodeAnalysis.IParameterSymbol _, Microsoft.CodeAnalysis.IParameterSymbol __) -> bool
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(Microsoft.CodeAnalysis.IPropertySymbol _, Microsoft.CodeAnalysis.IPropertySymbol __) -> bool
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(Microsoft.CodeAnalysis.ISymbol x, Microsoft.CodeAnalysis.ISymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(Microsoft.CodeAnalysis.ITypeSymbol _, Microsoft.CodeAnalysis.ITypeSymbol __) -> bool
static Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxNodeAnalysisContextExt.IsExcludedFromAnalysis(this Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext context) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxNodeExt.FileLinePositionSpan(this Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.FileLinePositionSpan
static Gu.Roslyn.AnalyzerExtensions.SyntaxNodeExt.FirstAncestor<T>(this Microsoft.CodeAnalysis.SyntaxNode node) -> T
static Gu.Roslyn.AnalyzerExtensions.SyntaxNodeExt.IsEither(this Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind1, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind2) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxNodeExt.IsInExpressionTree(this Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxNodeExt.SharesAncestor<T>(this Microsoft.CodeAnalysis.SyntaxNode first, Microsoft.CodeAnalysis.SyntaxNode other, out T ancestor) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxNodeExt.TryFindSharedAncestorRecursive<T>(this Microsoft.CodeAnalysis.SyntaxNode first, Microsoft.CodeAnalysis.SyntaxNode other, out T ancestor) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxNodeExt.TryFirstAncestor<T>(this Microsoft.CodeAnalysis.SyntaxNode node, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxNodeExt.TryFirstAncestorOrSelf<T>(this Microsoft.CodeAnalysis.SyntaxNode node, out T result) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxTokenExt.FileLinePositionSpan(this Microsoft.CodeAnalysis.SyntaxToken token, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.FileLinePositionSpan
static Gu.Roslyn.AnalyzerExtensions.SyntaxTokenExt.IsEither(this Microsoft.CodeAnalysis.SyntaxToken node, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind1, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind2) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxTokenExt.IsEither(this Microsoft.CodeAnalysis.SyntaxToken node, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind1, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind2, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind3) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxTokenListExt.Accessibility(this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.Accessibility whenMissing) -> Microsoft.CodeAnalysis.Accessibility
static Gu.Roslyn.AnalyzerExtensions.SyntaxTokenListExt.Any(this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind k1, Microsoft.CodeAnalysis.CSharp.SyntaxKind k2) -> bool
static Gu.Roslyn.AnalyzerExtensions.SyntaxTokenListExt.Any(this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind k1, Microsoft.CodeAnalysis.CSharp.SyntaxKind k2, Microsoft.CodeAnalysis.CSharp.SyntaxKind k3) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeDeclarationSyntaxExt.TryFindConstructor(this Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax type, System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax, bool> predicate, out Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax match) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeDeclarationSyntaxExt.TryFindConstructor(this Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax type, out Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax match) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeDeclarationSyntaxExt.TryFindEvent(this Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax type, string name, out Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax match) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeDeclarationSyntaxExt.TryFindField(this Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax type, string name, out Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax match) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeDeclarationSyntaxExt.TryFindIndexer(this Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax type, out Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax match) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeDeclarationSyntaxExt.TryFindMethod(this Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax type, System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax, bool> predicate, out Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax match) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeDeclarationSyntaxExt.TryFindMethod(this Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax type, string name, System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax, bool> predicate, out Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax match) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeDeclarationSyntaxExt.TryFindMethod(this Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax type, string name, out Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax match) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeDeclarationSyntaxExt.TryFindProperty(this Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax type, string name, out Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax match) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeSymbolComparer.Equals(Microsoft.CodeAnalysis.ITypeSymbol x, Microsoft.CodeAnalysis.ITypeSymbol y) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeSymbolComparer.Equals(object _, object __) -> bool
static Gu.Roslyn.AnalyzerExtensions.TypeSymbolComparer.GetHashCode(Microsoft.CodeAnalysis.ITypeSymbol obj) -> int
static Gu.Roslyn.AnalyzerExtensions.TypeSyntaxExt.IsVoid(this Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) -> bool
static Gu.Roslyn.AnalyzerExtensions.VariableDeclarationSyntaxExt.TryFindVariable(this Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax variableDeclaration, string name, out Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax result) -> bool
static Gu.Roslyn.AnalyzerExtensions.VariableDeclaratorWalker.Borrow(Microsoft.CodeAnalysis.SyntaxNode node) -> Gu.Roslyn.AnalyzerExtensions.VariableDeclaratorWalker
static Gu.Roslyn.AnalyzerExtensions.XmlElementSyntaxExtensions.HasLocalName(this Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax element, string localName) -> bool
static Gu.Roslyn.AnalyzerExtensions.XmlElementSyntaxExtensions.HasNameAttribute(this Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax element, string name) -> bool
static Gu.Roslyn.AnalyzerExtensions.XmlElementSyntaxExtensions.TryGetLocalName(this Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax element, out string localName) -> bool
static Gu.Roslyn.AnalyzerExtensions.XmlElementSyntaxExtensions.TryGetNameAttribute(this Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax element, out Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax attribute) -> bool
static readonly Gu.Roslyn.AnalyzerExtensions.AssemblySymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.AssemblySymbolComparer
static readonly Gu.Roslyn.AnalyzerExtensions.EventSymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.EventSymbolComparer
static readonly Gu.Roslyn.AnalyzerExtensions.FieldSymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.FieldSymbolComparer
static readonly Gu.Roslyn.AnalyzerExtensions.LocalSymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.LocalSymbolComparer
static readonly Gu.Roslyn.AnalyzerExtensions.MethodSymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.MethodSymbolComparer
static readonly Gu.Roslyn.AnalyzerExtensions.NamedTypeSymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.NamedTypeSymbolComparer
static readonly Gu.Roslyn.AnalyzerExtensions.NamespaceSymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.NamespaceSymbolComparer
static readonly Gu.Roslyn.AnalyzerExtensions.ParameterSymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.ParameterSymbolComparer
static readonly Gu.Roslyn.AnalyzerExtensions.PropertySymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.PropertySymbolComparer
static readonly Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.Boolean -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
static readonly Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.CodeDom.Compiler.GeneratedCodeAttribute -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
static readonly Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.NullableOfT -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
static readonly Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.Object -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
static readonly Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.Runtime.CompilerServices.CallerMemberNameAttribute -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
static readonly Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.Runtime.CompilerServices.CompilerGeneratedAttribute -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
static readonly Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.String -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
static readonly Gu.Roslyn.AnalyzerExtensions.QualifiedType.System.Void -> Gu.Roslyn.AnalyzerExtensions.QualifiedType
static readonly Gu.Roslyn.AnalyzerExtensions.QualifiedType.TypeAliasMap -> System.Collections.Generic.IReadOnlyDictionary<string, string>
static readonly Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.ConstructorDeclarationComparer.Default -> Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.ConstructorDeclarationComparer
static readonly Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.FieldDeclarationComparer.Default -> Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.FieldDeclarationComparer
static readonly Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.IndexerDeclarationComparer.Default -> Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.IndexerDeclarationComparer
static readonly Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.MethodDeclarationComparer.Default -> Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.MethodDeclarationComparer
static readonly Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.PropertyDeclarationComparer.Default -> Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.PropertyDeclarationComparer
static readonly Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.UsingDirectiveComparer.Default -> Gu.Roslyn.AnalyzerExtensions.StyleCopComparers.UsingDirectiveComparer
static readonly Gu.Roslyn.AnalyzerExtensions.SymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.SymbolComparer
static readonly Gu.Roslyn.AnalyzerExtensions.TypeSymbolComparer.Default -> Gu.Roslyn.AnalyzerExtensions.TypeSymbolComparer
virtual Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.IsPropertyGetAndSet(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) -> bool
virtual Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.IsPropertySet(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) -> bool
virtual Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.TryGetTargetSymbol<TSymbol>(Microsoft.CodeAnalysis.SyntaxNode node, out TSymbol symbol) -> bool
virtual Gu.Roslyn.AnalyzerExtensions.ExecutionWalker<T>.VisitTypeDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax node) -> void
virtual Gu.Roslyn.AnalyzerExtensions.QualifiedMember<T>.Equals(T symbol) -> bool
virtual Gu.Roslyn.AnalyzerExtensions.QualifiedType.Equals(Gu.Roslyn.AnalyzerExtensions.QualifiedType other) -> bool
virtual Gu.Roslyn.AnalyzerExtensions.QualifiedType.Equals(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) -> bool
virtual Gu.Roslyn.AnalyzerExtensions.QualifiedType.Equals(Microsoft.CodeAnalysis.ITypeSymbol type) -> bool
virtual Gu.Roslyn.AnalyzerExtensions.QualifiedType.GetTypeSymbol(Microsoft.CodeAnalysis.Compilation compilation) -> Microsoft.CodeAnalysis.ITypeSymbol
virtual Gu.Roslyn.AnalyzerExtensions.QualifiedType.NameEquals(string name) -> bool
